1. IPC using Socket programming

ipc-client.py
===================================================================
import socket


def main():
    try:
        client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        client_socket.connect(("localhost", 1200))

        print(" \n \t************* CLIENT PROCESS STARTED ********************** ")
        print(
            "\n ********* PLEASE ENTER THE VALUES OF Number 1 AND Number 2 TO PASS THEM TO SERVER PROCESS******** \n"
        )

        a = int(input("Enter Number 1: "))
        print("Number 1 ====>", a)
        client_socket.sendall(str(a).encode())

        b = int(input("Enter Number 2: "))
        print("Number 2 ====>", b)
        client_socket.sendall(str(b).encode())

        data = client_socket.recv(1024)
        result = int(data.decode())
        print(
            "\n.............CLIENT PROCESS HAS RECEIVED RESULT FROM SERVER...............\n"
        )
        print("\n THE ADDITION OF", a, "AND", b, "IS", result)

    except Exception as e:
        print("Exception is", e)

    finally:
        client_socket.close()


if __name__ == "__main__":
    main()

ipc-server.py
===================================================================
import socket


def main():
    print("\n **** INTERPROCESS COMMUNICATION ****\n")
    print("\n *** SERVER PROCESS STARTED ***\n")
    print(
        "\n * SERVER IS READY AND WAITING TO RECEIVE DATA FROM CLIENT PROCESS ON PORT 1200"
    )

    try:
        server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        server_socket.bind(("localhost", 1200))
        server_socket.listen(1)

        client_socket, client_address = server_socket.accept()
        print(
            "\n * Client is connected with IP address",
            client_address[0],
            "and port Number",
            client_address[1],
        )

        with client_socket:
            data = client_socket.recv(1024)
            a = int(data.decode())
            print("\n SERVER RECEIVED")
            print("\n Number 1 ====>", a)

            data = client_socket.recv(1024)
            b = int(data.decode())
            print("\n Number 2 ====>", b)

            c = a + b
            client_socket.sendall(str(c).encode())
            print(
                "\n SERVER PROCESS HAS EXECUTED REQUESTED PROCESS AND SENT RESULT",
                c,
                "TO THE CLIENT \n",
            )

    except Exception as e:
        print("Exception:", e)


if __name__ == "__main__":
    main()


2. Group COMMUNICATION

gc-client.py
===================================================================
import socket
import threading


def main():
    # Get client's name
    client_name = input("Enter your name: ")

    try:
        # Connect to the server
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as client_socket:
            client_socket.connect(("localhost", 8080))
            print("Connected to server.")

            # Send client's name to the server
            writer = client_socket.makefile("w")
            writer.write(client_name + "\n")
            writer.flush()

            # Start a thread to read messages from the server
            reader_thread = threading.Thread(
                target=client_reader, args=(client_socket,)
            )
            reader_thread.start()

            # Send messages to the server
            while True:
                message = input()
                writer.write(message + "\n")
                writer.flush()
                if message == "exit":
                    break

    except Exception as e:
        print("Error:", e)


def client_reader(client_socket):
    try:
        # Read messages from the server
        with client_socket.makefile("r") as reader:
            while True:
                message = reader.readline().strip()
                if not message:
                    break
                print(message)

    except Exception as e:
        print("Error:", e)
    finally:
        print("Disconnected from the server.")


if __name__ == "__main__":
    main()


gc-server.py
===================================================================
import socket
import threading


# Set up the server
def main():
    # Set up the server socket
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_socket.bind(("localhost", 8080))
    server_socket.listen(5)
    print("Group Chat Server is running...")

    # Set to store connected client sockets and their names
    connected_clients = {}

    # Function to handle client connections
    def client_handler(client_socket, client_name):
        try:
            while True:
                message = client_socket.recv(1024).decode()
                if not message:
                    break
                elif message == "exit":
                    break
                elif message.startswith("/whisper"):
                    handle_whisper(message)
                else:
                    broadcast(client_name + ": " + message)
        except Exception as e:
            print("Error:", e)
        finally:
            client_socket.close()
            del connected_clients[client_name]
            broadcast_from_server(client_name + " has left the chat.")

    # Function to broadcast a message to all clients
    def broadcast(message):
        for name, sock in connected_clients.items():
            sock.sendall(message.encode())

    # Function to handle whisper messages
    def handle_whisper(message):
        parts = message.split(" ", 2)
        if len(parts) == 3:
            recipient = parts[1].strip()
            whisper_message = parts[2].strip()
            if recipient in connected_clients:
                connected_clients[recipient].sendall(
                    f"(whisper from {client_name}): {whisper_message}".encode()
                )
            else:
                connected_clients[client_name].sendall(
                    f"Recipient '{recipient}' is not connected.".encode()
                )
        else:
            connected_clients[client_name].sendall(
                "Invalid whisper command. Usage: /whisper recipient message".encode()
            )

    # Function to handle server messages
    def server_message_handler():
        try:
            while True:
                server_message = input()
                broadcast_from_server("[host]: " + server_message)
        except Exception as e:
            print("Error:", e)

    # Function to broadcast a message from the server
    def broadcast_from_server(message):
        for name, sock in connected_clients.items():
            sock.sendall(message.encode())

    # Thread to handle server messages
    threading.Thread(target=server_message_handler, daemon=True).start()

    # Main loop to accept client connections
    while True:
        client_socket, client_address = server_socket.accept()
        client_name = client_socket.recv(1024).decode()
        print(f"New client connected: {client_name}")
        connected_clients[client_name] = client_socket
        broadcast_from_server(f"{client_name} has joined the chat.")
        broadcast_from_server("New member has joined !!")
        threading.Thread(
            target=client_handler, args=(client_socket, client_name), daemon=True
        ).start()


if __name__ == "__main__":
    main()


3. Global Averaging Method

ga.py
===================================================================
import time
import random


class Node:
    def __init__(self, node_id, clock_time):
        self.node_id = node_id
        self.clock_time = clock_time

    def synchronize_clock(self, master_time):
        self.clock_time = master_time


def master(node_list):
    # Request time from all nodes
    node_times_before = {}
    for node in node_list:
        node_times_before[node.node_id] = node.clock_time
        print("Master Node ===> ", node.node_id)
        print(f"{node.node_id} time: {node.clock_time} ===> Master Node")

    print("=" * 10)

    # Calculate average time
    average_time = sum(node_times_before.values()) / len(node_list)

    # Send synchronization message to all nodes
    for node in node_list:
        print(f"Master Node time: {average_time} ===> ", node.node_id)
        node.synchronize_clock(average_time)

    print("=" * 10)

    # Print before and after synchronization times for all nodes
    print("Before synchronization:")
    for node_id, time_before in node_times_before.items():
        print(f"Node {node_id} time: {time_before}")

    print("\nAfter synchronization:")
    for node in node_list:
        print(f"Node {node.node_id} time: {node.clock_time}")

    print("\nMaster node synchronized all nodes to time:", average_time)


if __name__ == "__main__":
    # Initialize master and nodes
    master_node = Node("Master", 0)
    nodes = [Node(f"Node-{i}", random.uniform(0, 10)) for i in range(1, 6)]

    # Simulate master node requesting and synchronizing time
    master(nodes)


4. Berkley Algorithm

berkley.py
===================================================================
from datetime import datetime


class Berkley:
    def diff(self, h, m, s, nh, nm, ns):
        dh = h - nh
        dm = m - nm
        ds = s - ns
        diff = (dh * 60 * 60) + (dm * 60) + ds
        return diff

    def average(self, diff, n):
        total = sum(diff)
        average = total / (n + 1)
        print("The average of all time differences is", average)
        return average

    def sync(self, diff, n, h, m, s, nh, nm, ns, average):
        for i in range(n):
            diff[i] += average
            dh = int(diff[i]) // (60 * 60)
            diff[i] %= 60 * 60
            dm = int(diff[i]) // 60
            diff[i] %= 60
            ds = int(diff[i])
            nh[i] += dh
            if nh[i] > 23:
                nh[i] %= 24
            nm[i] += dm
            if nm[i] > 59:
                nh[i] += 1
                nm[i] %= 60
            ns[i] += ds
            if ns[i] > 59:
                nm[i] += 1
                ns[i] %= 60
            if ns[i] < 0:
                nm[i] -= 1
                ns[i] += 60

        h += int(average) // (60 * 60)
        if h > 23:
            h %= 24
        m += int(average) // (60 * 60 * 60)
        if m > 59:
            h += 1
            m %= 60
        s += int(average) % (60 * 60 * 60)
        if s > 59:
            m += 1
            s %= 60
        if s < 0:
            m -= 1
            s += 60

        print("The synchronized clocks are:\nTime Server --->", h, ":", m, ":", s)
        for i in range(n):
            print("Node", (i + 1), "--->", nh[i], ":", nm[i], ":", ns[i])


def main():
    b = Berkley()
    now = datetime.now()
    print("Enter number of nodes:")
    n = int(input())
    h = now.hour
    m = now.minute
    s = now.second
    nh = []
    nm = []
    ns = []

    for i in range(n):
        print("Enter time for node", (i + 1))
        nh.append(int(input("Hours: ")))
        nm.append(int(input("Minutes: ")))
        ns.append(int(input("Seconds: ")))

    for i in range(n):
        print("Time Server sent time", h, ":", m, ":", s, "to node", (i + 1))

    diff = [b.diff(h, m, s, nh[i], nm[i], ns[i]) for i in range(n)]
    for i in range(n):
        print(
            "Node", (i + 1), "sent time difference of", int(diff[i]), "to Time Server."
        )

    average = b.average(diff, n)
    b.sync(diff, n, h, m, s, nh, nm, ns, average)


if __name__ == "__main__":
    main()


5. Bully Algorithm

bully.py
===================================================================
class BullyAlgo:
    def __init__(self):
        self.coordinator = None
        self.processes = []
        self.crashed_processes = set()

    def election(self):
        print("\nThe Coordinator Has Crashed!")
        while True:
            crash = sum(1 for p in self.processes if p == 0)
            if crash == len(self.processes):
                print("\n*** All Processes Are Crashed ***")
                break
            else:
                print("\nEnter The Initiator")
                init = int(input())
                if (
                    init < 1
                    or init > len(self.processes)
                    or self.processes[init - 1] == 0
                ):
                    print("\nInvalid Initiator")
                    continue

                for i in range(init - 1, len(self.processes)):
                    print("Process", i + 1, "Called For Election")
                print("")
                for i in range(init - 1, len(self.processes)):
                    if self.processes[i] == 0:
                        print("Process", i + 1, "Is Dead")
                    else:
                        print("Process", i + 1, "Is In")

                for i in range(len(self.processes) - 1, -1, -1):
                    if self.processes[i] == 1:
                        self.coordinator = i + 1
                        print("\n*** New Coordinator Is", self.coordinator, "***")
                        return

    def bully(self):
        print("Enter The Number Of Processes:")
        n = int(input())
        self.processes = [1] * n
        self.coordinator = n

        while True:
            print("\n\t1. Crash A Process")
            print("\t2. Recover A Process")
            print("\t3. Display New Coordinator")
            print("\t4. Exit")

            ch = int(input())
            if ch == 1:
                print("\nEnter A Process To Crash")
                cp = int(input())
                if cp > n or cp < 1:
                    print("Invalid Process! Enter A Valid Process")
                elif self.processes[cp - 1] == 1 and self.coordinator != cp:
                    self.processes[cp - 1] = 0
                    print("\nProcess", cp, "Has Been Crashed")
                elif self.processes[cp - 1] == 1 and self.coordinator == cp:
                    self.processes[cp - 1] = 0
                    self.election()
                else:
                    print("\nProcess", cp, "Is Already Crashed")

            elif ch == 2:
                print("\nCrashed Processes Are:")
                for i, p in enumerate(self.processes):
                    if p == 0:
                        print(i + 1)
                print("Enter The Process You Want To Recover")
                rp = int(input())
                if rp < 1 or rp > n:
                    print("\nInvalid Process. Enter A Valid ID")
                elif self.processes[rp - 1] == 0 and rp > self.coordinator:
                    self.processes[rp - 1] = 1
                    print("\nProcess", rp, "Has Recovered")
                    self.coordinator = rp
                    print("\nProcess", rp, "Is The New Coordinator")
                elif len(self.crashed_processes) == n:
                    self.processes[rp - 1] = 1
                    self.coordinator = rp
                    print("\nProcess", rp, "Is The New Coordinator")
                    self.crashed_processes.remove(rp)
                elif self.processes[rp - 1] == 0 and rp < self.coordinator:
                    self.processes[rp - 1] = 1
                    print("\nProcess", rp, "Has Recovered")
                else:
                    print("\nProcess", rp, "Is Not A Crashed Process")

            elif ch == 3:
                print("\nCurrent Coordinator Is", self.coordinator)

            elif ch == 4:
                break

            else:
                print("\nInvalid Entry!")


def main():
    ob = BullyAlgo()
    ob.bully()


if __name__ == "__main__":
    main()


6. Raymond Tree Algorithm

raymond.py
===================================================================
class Node:
    def __init__(self, id, holder):
        self.id = id
        self.holder = holder
        self.q = []


def request(holder, req):
    n = list[holder - 1]
    n.q.append(req)
    print("Queue of", n.id, ":", n.q)
    if n.holder != n.id:
        request(n.holder, n.id)
    else:
        give_token(n.id)


def give_token(nid):
    n = list[nid - 1]
    next = n.q.pop(0)
    n.holder = next
    if next != nid:
        give_token(next)
    else:
        print_function()


def print_function():
    for n in list:
        print("id:", n.id, "Holder:", n.holder)


if __name__ == "__main__":
    list = []
    n1 = Node(1, 1)
    n2 = Node(2, 1)
    n3 = Node(3, 1)
    n4 = Node(4, 2)
    n5 = Node(5, 2)
    n6 = Node(6, 3)
    n7 = Node(7, 3)
    n8 = Node(8, 3)
    list.extend([n1, n2, n3, n4, n5, n6, n7, n8])

    while True:
        print(
            "Enter the ID of the node requesting access to the critical section (1-8), or 'exit' to quit:"
        )
        input_val = input()
        if input_val.lower() == "exit":
            break

        try:
            node_id = int(input_val)
            if node_id < 1 or node_id > 8:
                print("Invalid node ID. Please enter a number between 1 and 8.")
                continue
        except ValueError:
            print("Invalid input. Please enter a valid node ID or 'exit'.")
            continue

        request(node_id, node_id)


7. Ricart-Agrawala Algorithm

ricart.py
===================================================================
def main():
    ns = int(input("Enter number of sites: "))
    ncs = int(input("Enter number of sites which want to enter critical section: "))

    ts = [0] * ns
    request = []
    mp = {}

    for _ in range(ncs):
        timestamp = int(input("\nEnter timestamp: "))
        site = int(input("Enter site number: "))
        ts[site - 1] = timestamp
        request.append(site)
        mp[timestamp] = site

    print("\nSites and Timestamp:\n")
    for i in range(len(ts)):
        print(i + 1, ts[i])

    for i in range(len(request)):
        print("\nRequest from site:", request[i])
        for j in range(len(ts)):
            if request[i] != (j + 1):
                if ts[j] > ts[request[i] - 1] or ts[j] == 0:
                    print(j + 1, "Replied")
                else:
                    print(j + 1, "Deferred")

    print()
    c = 0
    for timestamp, site in mp.items():
        print("Site", site, "entered Critical Section", "at timestamp", timestamp)


if __name__ == "__main__":
    main()


8. Banker's Algorithm

bankers.py
===================================================================
def is_safe(processes, avail, maxm, allot):
    need = []
    for i in range(len(processes)):
        need.append([0] * len(avail))
        for j in range(len(avail)):
            need[i][j] = maxm[i][j] - allot[i][j]

    finish = [0] * len(processes)
    safe_seq = []
    work = avail[:]

    while True:
        found = False
        for i in range(len(processes)):
            if finish[i] == 0:
                if all(need[i][j] <= work[j] for j in range(len(avail))):
                    for j in range(len(avail)):
                        work[j] += allot[i][j]
                    safe_seq.append(i)
                    finish[i] = 1
                    found = True
                    break
        if not found:
            break

    return all(finish), safe_seq


def main():
    n = int(input("Enter number of processes: "))
    m = int(input("Enter number of resources: "))

    print("Enter Allocation Matrix:")
    allocation = [list(map(int, input().split())) for _ in range(n)]

    print("Enter Max Matrix:")
    max_matrix = [list(map(int, input().split())) for _ in range(n)]

    print("Enter Available Resources:")
    available = list(map(int, input().split()))

    processes = [i for i in range(n)]

    safe, sequence = is_safe(processes, available, max_matrix, allocation)

    if safe:
        print("System is in safe state.")
        print("Safe sequence is:", [i + 1 for i in sequence])
    else:
        print("System is in unsafe state.")
        for i, process in enumerate(processes):
            if process not in sequence:
                print("Resources cannot be granted for process", process + 1)

    for i in sequence:
        print("Resources granted for process", i + 1, "successfully.")
        print("Available resources after process", i + 1, ":")
        available = [avail + alloc for avail, alloc in zip(available, allocation[i])]
        print(*available)


if __name__ == "__main__":
    main()

9. Load balancing

lb.py
===================================================================
def print_load(servers, processes):
    each = processes // servers
    extra = processes % servers
    total = 0
    for i in range(servers):
        if extra > 0:
            total = each + 1
            extra -= 1
        else:
            total = each
        print(f"Server {chr(ord('A') + i)} has {total} Processes")


def main():
    servers = int(input("Enter the number of servers: "))
    processes = int(input("Enter the number of Processes: "))
    while True:
        print_load(servers, processes)
        print(
            "1. Add Servers\n2. Remove Servers\n3. Add Processes\n4. Remove Processes\n5. Exit"
        )
        choice = int(input("Enter your choice: "))
        if choice == 1:
            servers += int(input("How many more servers?: "))
        elif choice == 2:
            servers -= int(input("How many servers to remove?: "))
        elif choice == 3:
            processes += int(input("How many more Processes?: "))
        elif choice == 4:
            processes -= int(input("How many Processes to remove?: "))
        elif choice == 5:
            return
        else:
            print("Invalid choice. Please enter a valid option.")


if __name__ == "__main__":
    main()


10. Multithreading

mt.py
===================================================================
from threading import Thread
import time


class Threads(Thread):
    def __init__(self):
        super().__init__(name="User Threads")
        print("User thread is created", self)
        self.start()

    def run(self):
        try:
            for i in range(8):
                print("Printing the count of Child Thread", i)
                time.sleep(0.8)
        except InterruptedException as e:
            print("User thread interrupted")
        print("Child thread run is over")


class Multithreading:
    def main(self):
        th = Threads()
        try:
            while th.is_alive():
                print("Parent thread will run till the Child thread is alive")
                time.sleep(1.5)
        except InterruptedException as e:
            print("Parent thread interrupted")
        print("Parent thread's run is over")


if __name__ == "__main__":
    m = Multithreading()
    m.main()
